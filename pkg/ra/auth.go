package ra

import (
	"crypto/hmac"
	"crypto/sha256"

	"github.com/wang12d/GoMarlin/marlin"
)

// Auth generates the zero-knowledge proof of the requirement
func Auth(prefix, msg, sk, pk, cert, mpk []byte) ([]byte, []byte, marlin.Proof, marlin.VerifyKey) {
	t1 := pairHash(prefix, sk)
	prefixWithMsg := make([]byte, len(prefix)+len(msg))
	copy(prefixWithMsg[:len(prefix)], prefix)
	copy(prefixWithMsg[len(prefix):], msg)
	t2 := pairHash(prefixWithMsg, sk)
	proof, vk := marlin.ZebraLancerGenerateProofAndVerifyKey(prefix, msg, sk, pk, cert, mpk, t1, t2)
	return t1, t2, proof, vk
}

// Verify using the common knowledge and public input to verify proof generated by
// marlin.
func Verify(prefix, msg, mpk, t1, t2 []byte, proof marlin.Proof, vk marlin.VerifyKey) bool {
	return marlin.ZebraLancerVerifyProof(
		prefix, msg, mpk, t1, t2, proof, vk,
	)
}

func pairHash(key, val []byte) []byte {
	h := hmac.New(sha256.New, key)
	h.Write(val)
	return h.Sum(nil)
}
