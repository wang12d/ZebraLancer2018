package ra

import (
	"crypto"
	"crypto/ed25519"
	"crypto/rsa"
	"crypto/sha256"
	"log"
	"sync"

	"github.com/wang12d/Go-Crowdsourcing-DApp/pkg/crowdsourcing/utils/cryptograph"
	"github.com/wang12d/ZebraLancer2018/pkg"
)

type Certificate []byte

type RegisterAuthority interface {
	CertGen(msg []byte) (Certificate, error)
}
type ra struct {
	msk *rsa.PrivateKey
	mpk *rsa.PublicKey
}

var (
	RA     *ra
	RAInit sync.Once
)

func init() {
	RAInit.Do(
		func() {
			pk, sk, err := pkg.Setup()
			if err != nil {
				log.Fatalf("RA key generation error: %v\n", err)
			}
			RA = &ra{
				msk: sk,
				mpk: pk,
			}
		})
}

// CertGen certificate the public key using master secret key by the RA
func (a *ra) CertGen(msg []byte) (Certificate, error) {
	digest := sha256.Sum256(msg)
	return rsa.SignPKCS1v15(nil, a.msk, crypto.SHA256, digest[:])
}

// Mpk return the public key of register authority
func (a *ra) Mpk() []byte {
	mpkBytes, err := cryptograph.ExportRsaPublicKeyAsPem(a.mpk)
	if err != nil {
		log.Fatalf("Convert RSA public key to bytes error: %v\n", err)
	}
	return mpkBytes
}

// PublicKey returns the public key of register authority
func (a *ra) PublickKey() *rsa.PublicKey {
	return a.mpk
}

// CertVrfy verifies the certification of public key generated by the CA
func CertVrfy(cert Certificate, msg []byte, mpk *rsa.PublicKey) bool {
	digest := sha256.Sum256(msg)
	err := rsa.VerifyPKCS1v15(mpk, crypto.SHA256, digest[:], cert)
	return err == nil
}

// Pair verifies that the public key is corresponding to the private key
func Pair(pk ed25519.PublicKey, sk ed25519.PrivateKey) bool {
	return pk.Equal(sk.Public())
}
